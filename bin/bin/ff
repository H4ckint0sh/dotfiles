#!/usr/bin/env bash
#
# Author: Davide Galassi <davxy@datawok.net>
# Version: 0.1.2
#
# Fast tool to search into files using fuzzy finder
#
# Depends on
# - ripgrep
# - fzf
# - pbcopy (optional): to copy to clipboard a result via <C-y>.
#                       Can be replaced by any clipboard manager.
#
# Assumptions for live editor open:
# - When using the `EDITOR` env variable set to default editor.
# - The editor of choice should be able to open a file like: `$EDITOR finapath:line`

# Options
edit=0
ignore_case="+i"
query=""
exit_on_exec=0
fzf_nth="3.."

# FZF key bindings
COPY_FILE_PATH='ctrl-y:execute(echo -n {1}:{2} | pbcopy)'
KEYS="$COPY_FILE_PATH"

function help() {
    echo "Usage: ff [options] [FILE]"    
    echo "  -e: Edit the selected file(s)"
    echo "  -i: Case insensitive search"
    echo "  -h: Display this help message"
    echo "  -q: Query"
    echo "  -x: Exit on execution"
    echo "  -f: Include file path"
    echo "  FILE: Specify the input file or directory to search into (default CWD)"
    exit
}

function search_folder() {
    while true; do
        # Search using rg and fzf with preview
        out=$(rg . --line-number --no-heading --glob '!.git' | \
              fzf -m ${ignore_case} \
                --no-sort \
                --tac \
                --exact \
                --delimiter ':' \
                --nth "$fzf_nth" \
                --exit-0 \
                --multi \
                --print-query --query="$query" \
                --preview 'bat --style=full --color=always --highlight-line {2} {1}' \
                --preview-window 'right,~4,+{2}+4/2' \
                --bind "$KEYS")

        if [[ $? != 0 ]]; then
            exit
        fi

        # Extract new query
        query=$(echo "$out" | cut -d$'\n' -f1)
        # Remove cruft leaving something like: 'file:line'
        results=$(echo "$out" | cut -d$'\n' -f2- | sed -E 's/([^:]*):([0-9]*):.*/\1:\2/')

        # Check if we want to edit the results
        if [[ $edit == 1 && $results != "" ]]; then
            $EDITOR $results
        else
            IFS=$'\n' mapfile -t selected_matches <<< "$results"
            for element in "${selected_matches[@]}"; do
                echo $element
            done
            exit
        fi
    done
}

function search_file() {
    file="$1"

    tmpfile=""
    if [ ! -f $file ]; then
        tmpfile=$(mktemp)
        dd if=$file of="$tmpfile" bs=1M count=1 2>/dev/null
        cat $tmpfile
        file=$tmpfile
    fi

    preview_cmd="bat --style=full --color=always --highlight-line {1} $file"
    preview_win="right,~4,+{1}+4/2"
    while true; do
        result=$(bat --plain --color always $file | \
            nl -ba -w1 -s": " | \
            fzf --ansi +i --delimiter ':' \
                --exact --no-sort --tac --nth "2.." \
                --print-query --query="$query" \
                --preview "$preview_cmd" \
                --preview-window "$preview_win" | \
            awk '{ print $1 }' |
            sed 's/:$//')

        if [[ $result == "" ]]; then
            exit
        fi

        # Extract new query
        query=$(echo "$result" | cut -d$'\n' -f1)
        line=$(echo "$result" | cut -d$'\n' -f2)

        fl="${file}:${line}"
        if [[ $edit == 1 ]]; then
            $EDITOR $fl
        else
            echo $fl
            exit
        fi
    done

    rm -f $tmpfile
}

while getopts "eiq:xfh" opt; do
    case $opt in
        e) edit=1 ;;
        i) ignore_case="-i" ;;
        q) query="$OPTARG" ;;
        x) exit_on_exec=1 ;;
        f) fzf_nth="1.." ;;
        h | *) help ;;
    esac
done

if [ -p /dev/stdin ]; then
    path="/dev/stdin"
else
    # Check if there is a file or a folder
    shift $((OPTIND-1))
    if [ $# -gt 0 ]; then
        path="$1"
    else
        path="$PWD"
    fi
fi

# Optional flag for execution and exit behavior
if [[ $exit_on_exec == 1 ]]; then
  KEYS="$KEYS+abort"
fi

if [[ $include_file == 1 ]]; then
    fzf_nth=
fi

if [ -d "$path" ]; then
    pushd "$path" > /dev/null
    search_folder
    popd > /dev/null
else
    search_file "$path"
fi
